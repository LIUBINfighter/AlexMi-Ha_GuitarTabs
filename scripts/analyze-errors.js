#!/usr/bin/env node
/**
 * analyze-errors.js
 * 
 * Analyzes the report.json generated by gp-error-filter.js and provides
 * statistical insights into error types, distributions, and patterns.
 * 
 * Usage:
 *   node scripts/analyze-errors.js [--report path/to/report.json]
 */

const fs = require('fs').promises;
const path = require('path');

function parseArgs() {
  const args = process.argv.slice(2);
  const opts = { report: 'data/error/report.json' };
  
  for (let i = 0; i < args.length; i++) {
    const arg = args[i];
    if (arg === '--report' || arg === '-r') {
      opts.report = args[++i];
    } else if (arg === '--help' || arg === '-h') {
      console.log('Usage: node scripts/analyze-errors.js [--report path/to/report.json]');
      process.exit(0);
    } else {
      console.warn('Unknown argument:', arg);
    }
  }
  
  return opts;
}

function analyzeErrorCodes(results) {
  const errorCodeStats = new Map();
  const errorsByFile = [];
  
  for (const result of results) {
    if (result.status !== 'failed' || !result.diagnostics) continue;
    
    const fileErrors = {
      file: result.input,
      errorCount: result.errorCount,
      errors: {
        lexer: result.diagnostics.lexerErrors?.length || 0,
        parser: result.diagnostics.parserErrors?.length || 0,
        semantic: result.diagnostics.semanticErrors?.length || 0
      },
      codes: []
    };
    
    // Collect all error types
    const allErrors = [
      ...(result.diagnostics.lexerErrors || []),
      ...(result.diagnostics.parserErrors || []),
      ...(result.diagnostics.semanticErrors || [])
    ];
    
    for (const error of allErrors) {
      const code = error.code || 'unknown';
      const message = error.message || 'No message';
      
      fileErrors.codes.push(code);
      
      if (!errorCodeStats.has(code)) {
        errorCodeStats.set(code, {
          code,
          count: 0,
          files: new Set(),
          sampleMessage: message
        });
      }
      
      const stats = errorCodeStats.get(code);
      stats.count++;
      stats.files.add(result.input);
    }
    
    errorsByFile.push(fileErrors);
  }
  
  return { errorCodeStats, errorsByFile };
}

function categorizeErrorMessages(results) {
  const messagePatterns = new Map();
  
  for (const result of results) {
    if (result.status !== 'failed' || !result.diagnostics) continue;
    
    const allErrors = [
      ...(result.diagnostics.lexerErrors || []),
      ...(result.diagnostics.parserErrors || []),
      ...(result.diagnostics.semanticErrors || [])
    ];
    
    for (const error of allErrors) {
      const msg = error.message || 'No message';
      
      // Extract key patterns
      let pattern = 'Other';
      if (msg.includes('percussion articulation')) {
        pattern = 'Percussion Articulation';
      } else if (msg.includes('Wrong note kind')) {
        pattern = 'Note Kind Mismatch';
      } else if (msg.includes('Unexpected')) {
        pattern = 'Unexpected Value';
      } else if (msg.includes('Expected')) {
        pattern = 'Expected Token';
      } else if (msg.includes('Invalid')) {
        pattern = 'Invalid Syntax';
      }
      
      if (!messagePatterns.has(pattern)) {
        messagePatterns.set(pattern, {
          pattern,
          count: 0,
          files: new Set(),
          examples: []
        });
      }
      
      const stats = messagePatterns.get(pattern);
      stats.count++;
      stats.files.add(result.input);
      
      if (stats.examples.length < 3) {
        stats.examples.push({
          file: result.input,
          message: msg.substring(0, 150) + (msg.length > 150 ? '...' : '')
        });
      }
    }
  }
  
  return messagePatterns;
}

function generateReport(data) {
  const { report, errorCodeStats, errorsByFile, messagePatterns } = data;
  
  const output = [];
  
  output.push('═══════════════════════════════════════════════════════════════');
  output.push('                   ERROR ANALYSIS REPORT                       ');
  output.push('═══════════════════════════════════════════════════════════════');
  output.push('');
  
  // Overview
  output.push('OVERVIEW');
  output.push('─────────────────────────────────────────────────────────────');
  output.push(`Generated At:     ${new Date(report.generatedAt).toLocaleString()}`);
  output.push(`Input Directory:  ${report.inputDir}`);
  output.push(`Total Files:      ${report.totalFiles}`);
  output.push(`Passed:           ${report.passed} (${(report.passed / report.totalFiles * 100).toFixed(1)}%)`);
  output.push(`Failed:           ${report.failed} (${(report.failed / report.totalFiles * 100).toFixed(1)}%)`);
  output.push('');
  
  // Error Type Distribution
  let totalLexer = 0, totalParser = 0, totalSemantic = 0;
  for (const item of errorsByFile) {
    totalLexer += item.errors.lexer;
    totalParser += item.errors.parser;
    totalSemantic += item.errors.semantic;
  }
  const totalErrors = totalLexer + totalParser + totalSemantic;
  
  output.push('ERROR TYPE DISTRIBUTION');
  output.push('─────────────────────────────────────────────────────────────');
  output.push(`Lexer Errors:     ${totalLexer.toString().padStart(4)} (${(totalLexer / totalErrors * 100).toFixed(1)}%)`);
  output.push(`Parser Errors:    ${totalParser.toString().padStart(4)} (${(totalParser / totalErrors * 100).toFixed(1)}%)`);
  output.push(`Semantic Errors:  ${totalSemantic.toString().padStart(4)} (${(totalSemantic / totalErrors * 100).toFixed(1)}%)`);
  output.push(`Total:            ${totalErrors.toString().padStart(4)}`);
  output.push('');
  
  // Top Error Codes
  const sortedCodes = Array.from(errorCodeStats.values())
    .sort((a, b) => b.count - a.count);
  
  output.push('TOP ERROR CODES');
  output.push('─────────────────────────────────────────────────────────────');
  output.push('Code   Count  Files  Sample Message');
  output.push('─────────────────────────────────────────────────────────────');
  
  for (const stat of sortedCodes.slice(0, 10)) {
    const code = String(stat.code).padStart(5);
    const count = String(stat.count).padStart(5);
    const files = String(stat.files.size).padStart(5);
    const msg = stat.sampleMessage.substring(0, 50);
    output.push(`${code}  ${count}  ${files}  ${msg}...`);
  }
  output.push('');
  
  // Error Message Patterns
  const sortedPatterns = Array.from(messagePatterns.values())
    .sort((a, b) => b.count - a.count);
  
  output.push('ERROR MESSAGE PATTERNS');
  output.push('─────────────────────────────────────────────────────────────');
  
  for (const pattern of sortedPatterns) {
    output.push(`\n${pattern.pattern}`);
    output.push(`  Count:       ${pattern.count}`);
    output.push(`  Affected:    ${pattern.files.size} files`);
    output.push(`  Examples:`);
    for (const example of pattern.examples) {
      output.push(`    - ${example.file}`);
      output.push(`      ${example.message}`);
    }
  }
  output.push('');
  
  // Files with Most Errors
  const sortedFiles = errorsByFile.sort((a, b) => b.errorCount - a.errorCount);
  
  output.push('FILES WITH MOST ERRORS (Top 10)');
  output.push('─────────────────────────────────────────────────────────────');
  output.push('Errors  File');
  output.push('─────────────────────────────────────────────────────────────');
  
  for (const item of sortedFiles.slice(0, 10)) {
    const count = String(item.errorCount).padStart(6);
    output.push(`${count}  ${item.file}`);
  }
  output.push('');
  
  // Summary by Error Type per File
  output.push('ERROR BREAKDOWN BY FILE');
  output.push('─────────────────────────────────────────────────────────────');
  output.push('File                                      L    P    S   Total');
  output.push('─────────────────────────────────────────────────────────────');
  
  for (const item of sortedFiles) {
    const fileName = item.file.padEnd(42).substring(0, 42);
    const lexer = String(item.errors.lexer).padStart(3);
    const parser = String(item.errors.parser).padStart(3);
    const semantic = String(item.errors.semantic).padStart(3);
    const total = String(item.errorCount).padStart(6);
    output.push(`${fileName} ${lexer}  ${parser}  ${semantic}  ${total}`);
  }
  output.push('');
  output.push('Legend: L=Lexer, P=Parser, S=Semantic');
  output.push('═══════════════════════════════════════════════════════════════');
  
  return output.join('\n');
}

async function main() {
  const opts = parseArgs();
  const reportPath = path.resolve(opts.report);
  
  console.log('Loading report from:', reportPath);
  
  try {
    const reportData = await fs.readFile(reportPath, 'utf8');
    const report = JSON.parse(reportData);
    
    if (!report.results || !Array.isArray(report.results)) {
      console.error('Error: Invalid report format. Expected "results" array.');
      process.exit(1);
    }
    
    console.log('Analyzing errors...\n');
    
    const { errorCodeStats, errorsByFile } = analyzeErrorCodes(report.results);
    const messagePatterns = categorizeErrorMessages(report.results);
    
    const reportText = generateReport({
      report,
      errorCodeStats,
      errorsByFile,
      messagePatterns
    });
    
    console.log(reportText);
    
    // Save analysis to file
    const analysisPath = path.join(path.dirname(reportPath), 'error-analysis.txt');
    await fs.writeFile(analysisPath, reportText, 'utf8');
    console.log(`\nAnalysis saved to: ${analysisPath}`);
    
  } catch (error) {
    if (error.code === 'ENOENT') {
      console.error(`Error: Report file not found at ${reportPath}`);
      console.error('Please run gp-error-filter.js first to generate the report.');
    } else {
      console.error('Error:', error.message);
    }
    process.exit(1);
  }
}

if (require.main === module) {
  main().catch(err => {
    console.error('Fatal error:', err);
    process.exit(1);
  });
}
